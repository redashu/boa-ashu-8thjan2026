# Terraform Version Pinning & Module Version Locking (Enterprise-grade)

## 1. Business Problem (BOA Context)

In large banks like BOA:

### Real-World Risk Scenario

Multiple teams run Terraform from:

- Developer laptops
- CI/CD pipelines

Terraform and provider upgrades can:

- Change behavior silently
- Break plans
- Cause unexpected infra changes

### Real Risk Example

- Dev runs Terraform 1.3.x
- CI runs Terraform 1.6.x
- Module behavior differs → plan mismatch
- Result: deployment failure or drift

➡️ BOA requires deterministic, repeatable builds

## 2. Solution Overview

We enforce three layers of locking:

1. Terraform CLI version pinning
2. Provider version constraints
3. Terraform module version locking

This guarantees:

- Same plan
- Same apply
- Same result — everywhere

## 3. Terraform Version Pinning (MANDATORY)

### Root versions.tf

```hcl
terraform {
  required_version = "~> 1.5.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.20"
    }
  }
}
```

### What this means (Explain to customer)

- `~> 1.5.0` → allows 1.5.x only
- Terraform 1.6 or 1.4 ❌ blocked
- Ensures known-stable version

### Demo Tip

Run: `terraform version`

Then change local version → show failure

## 4. Provider Version Locking (terraform.lock.hcl)

Generated automatically with `terraform init`

Terraform creates: `terraform.lock.hcl`

### Why BOA cares

- Locks exact provider checksum
- Prevents compromised providers
- Prevents silent provider upgrades

### Enterprise Rule

✅ Commit `terraform.lock.hcl` to Git

This is non-negotiable in banks

## 5. Module Version Locking (Core of This Demo)

### Scenario

BOA uses a standard EC2 module across teams.

### Root Module

```hcl
module "ec2_app" {
  source  = "git::https://github.com/boa-platform/terraform-aws-ec2.git"
  version = "v1.2.0"

  instance_name = "payments-app"
  instance_type = "t3.medium"
}
```

### Why this matters

Every team gets:

- Same module logic
- Same security defaults
- No accidental breaking changes

## 6. What Happens If Module Changes?

### Example

- v1.2.0 → uses encrypted EBS
- v1.3.0 → adds lifecycle change
- Team upgrades only after approval

➡️ Controlled change management

## 7. Recommended Versioning Strategy (BOA-Style)

| Component | Strategy |
|-----------|----------|
| Terraform CLI | ~> minor |
| Providers | ~> minor |
| Modules | Exact version tag |
| State Backend | Central S3 + DynamoDB |

## 8. Folder Structure (Enterprise-Ready)

```
terraform-boa-app/
├── versions.tf
├── backend.tf
├── main.tf
├── variables.tf
├── terraform.lock.hcl
└── envs/
    ├── dev.tfvars
    ├── stage.tfvars
    └── prod.tfvars
```

## 9. CI/CD Enforcement (Very Important Talking Point)

In Jenkins / GitHub Actions:

```bash
terraform init -lockfile=readonly
terraform plan
```

### Why?

- Prevents provider upgrades in CI
- Forces engineers to update lock file explicitly

## 10. How You Should Present This to BOA

Use this one-liner:

> "This setup ensures infrastructure builds are deterministic, auditable, and immune to accidental version drift — which is critical for regulated banking environments."

## 11. Demo Flow (Live)

1. Show `required_version`
2. Show `terraform.lock.hcl`
3. Show module with pinned version
4. Break it intentionally (upgrade Terraform)
5. Show failure → explain why this protects prod
